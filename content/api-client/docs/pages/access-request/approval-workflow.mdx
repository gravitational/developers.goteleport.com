---
title: Auto Approval Workflow
description: Access request approval workflow
h1: Auto Approval Workflow
layout: tocless-doc
---


This example plugin demonstrates how to create a workflows plugin to automatically approve/deny new access requests based on a simple Allow List.

## Configure Resources 
Create Access Request Plugin.

```yaml
$ vi access-plugin.yaml

kind: user
metadata:
  name: access-plugin
spec:
  roles: ['access-plugin']
version: v2
---
kind: role
metadata:
  name: access-plugin
spec:
  allow:
    rules:
      - resources: ['access_request']
        verbs: ['list','read','update']
version: v4
```


### Create resources

Create the access-plugin user and role
```sh
$ tctl create -f access-plugin.yaml
```


## Create config file
This config file configures an allow list for auto approval.

```yaml
$ vi config.toml

# Teleport config values
....

# Teleport identity file with TLS/SSH certificates.
identity_file = "access-plugin-identity"

# allow_list determines which users' requests will be approved.
allow_list = [
    "alice",
    "bob",
]
```

## Create Plugin

```go

// Create new client
client, err := client.New(ctx, client.Config{
	...
})

// Create pending request filter
filter := types.AccessRequestFilter{
	State: types.RequestState_PENDING,
}

// Register a watcher for pending access requests.
watcher, err := client.NewWatcher(ctx, types.Watch{
	Kinds: []types.WatchKind{{
		Kind:   types.KindAccessRequest,
		Filter: filter.IntoMap(),
	}},
})

defer watcher.Close()

for {
	select {
	case event := <-watcher.Events():
		switch event.Type {
		case types.OpInit:
			log.Printf("watcher initialized...")
		case types.OpPut:
			// OpPut indicates that a request has been created or updated. Since we specified
			// StatePending in our filter, only pending requests should appear here.
			log.Printf("Handling request: %+v", event.Resource)

			req, ok := event.Resource.(*types.AccessRequestV3)
			if !ok {
				return trace.BadParameter("unexpected resource type %T", event.Resource)
			}

			// Gather AccessRequestUpdate params
			params := types.AccessRequestUpdate{
				RequestID: req.GetName(),
				Annotations: map[string][]string{
					"strategy": {"allow_list"},
				},
			}

			// Searching through allowList for a user match
			// and update the request state accordingly.
			allowed := false
			for _, user := range cfg.AllowList {
				if req.GetUser() == user {
					allowed = true
					break
				}
			}
			if allowed {
				log.Printf("User %q in Allow List, approving request...", req.GetUser())
				params.State = types.RequestState_APPROVED
				params.Reason = "user in Allow List"
			} else {
				log.Printf("User %q not in Allow List, denying request...", req.GetUser())
				params.State = types.RequestState_DENIED
				params.Reason = "user not in Allow List"
			}

		// Set delegator so that the event generated by setting the access
		// request state has an event field 'delegator: <plugin_name>:<delegator>'
		delegator := "delegator"
		ctx = utils.WithDelegator(ctx, fmt.Sprintf("%s:%s", cfg.PluginName, delegator))
		if err := client.SetAccessRequestState(ctx, params); err != nil {
	    	return trace.Wrap(err)
		}
		log.Printf("Request state set: %v.", params.State)
		case types.OpDelete:
			// request has been removed (expired).
			// Due to some limitations in Teleport's event system, filters
			// don't really work with OpDelete events. As such, we may get
			// OpDelete events for requests that would not typically match
			// the filter argument we supplied above.
			log.Printf("Request %s has automatically expired.", event.Resource.GetName())
		}
	case <-watcher.Done():
		return watcher.Error()
	}
}

```

Now start the plugin and keep it running.
```sh
$ go run plugin.go
```


## Making Access Request

### Create the requester role

```sh
$ vi requester.yaml

kind: role
metadata:
  name: requester
spec:
  allow:
    request:
      roles:
        - admin
version: v4

$ tctl create -f requester.yaml
```

### Create a new user named alice using this role
```sh
$ tctl users add alice --roles=requester
```

### Login as alice
```sh
$ tsh --proxy=proxy.example.com login --user=alice
```

### Request the admin role as alice
```sh
$ tsh --proxy=proxy.example.com request new --roles=admin
```

Since `alice` is on the Allow List in `cofig.toml` with allowed role `requester`, the request should be automatically approved by the plugin.