---
title: Auto Approval Workflow
description: Access request approval workflow
h1: Auto Approval Workflow
layout: tocless-doc
---


This example plugin demonstrates how to create a workflows plugin to automatically approve/deny new access requests based on a simple Allow List.

### Access Plugin

```yaml
$ vi access-plugin.yaml

kind: user
metadata:
  name: access-plugin
spec:
  roles: ['access-plugin']
version: v2
---
kind: role
metadata:
  name: access-plugin
spec:
  allow:
    rules:
      - resources: ['access_request']
        verbs: ['list','read','update']
version: v4
```

### Requester config

```yaml
$ vi requester.yaml

kind: role
metadata:
  name: requester
spec:
  allow:
    request:
      roles:
        - admin
version: v4
```


### Teleport config file to read identity file 

```yaml
$ vi config.toml

# Teleport config values
....
# plugin name used to associate data with the plugin
plugin_name = "example"

# Teleport Auth/Proxy address
addr = "localhost:3025"

# Teleport identity file with TLS/SSH certificates.
identity_file = "access-plugin-identity"

# allow_list determines which users' requests will be approved.
allow_list = [
    "alice",
    "bob",
]
```

### Your API client

#### Load config

```go 
type config struct {
	// PluginName is used to associate events and stored plugin data with a plugin
	PluginName string `toml:"plugin_name"`
	// Addr is the address used to connect to your Teleport Auth server. This can
	// be the auth, proxy, or tunnel proxy address.
	Addr string `toml:"addr"`
	// IdentityFile is used to authenticate a connection to the Teleport
	// Auth server and authorize client requests.
	IdentityFile string `toml:"identity_file"`
	// AllowList is a list of users to automatically approve access requests for.
	AllowList []string `toml:"allow_list"`
}

func loadConfig(filepath string) (*config, error) {
	t, err := toml.LoadFile(filepath)
	if err != nil {
		return nil, trace.Wrap(err)
	}
	conf := &config{}
	if err := t.Unmarshal(conf); err != nil {
		return nil, trace.Wrap(err)
	}
	return conf, nil
}
```

#### Run 

```go
client, err := client.New(ctx, client.Config{
	Addrs: []string{cfg.Addr},
	Credentials: []client.Credentials{
		client.LoadIdentityFile(cfg.IdentityFile),
	},
})



filter := types.AccessRequestFilter{
	State: types.RequestState_PENDING,
}

// Register a watcher for pending access requests.
watcher, err := client.NewWatcher(ctx, types.Watch{
	Kinds: []types.WatchKind{{
		Kind:   types.KindAccessRequest,
		Filter: filter.IntoMap(),
	}},
})

defer watcher.Close()

for {
	select {
	case event := <-watcher.Events():
		switch event.Type {
		case types.OpInit:
			log.Printf("watcher initialized...")
		case types.OpPut:
			// OpPut indicates that a request has been created or updated. Since we specified
			// StatePending in our filter, only pending requests should appear here.
			log.Printf("Handling request: %+v", event.Resource)

			req, ok := event.Resource.(*types.AccessRequestV3)
			if !ok {
				return trace.BadParameter("unexpected resource type %T", event.Resource)
			}

			// Gather AccessRequestUpdate params
			params := types.AccessRequestUpdate{
				RequestID: req.GetName(),
				Annotations: map[string][]string{
					"strategy": {"allow_list"},
				},
			}

			// Searching through allowList for a user match
			// and update the request state accordingly.
			allowed := false
			for _, user := range cfg.AllowList {
				if req.GetUser() == user {
					allowed = true
					break
				}
			}
			if allowed {
				log.Printf("User %q in Allow List, approving request...", req.GetUser())
				params.State = types.RequestState_APPROVED
				params.Reason = "user in Allow List"
			} else {
				log.Printf("User %q not in Allow List, denying request...", req.GetUser())
				params.State = types.RequestState_DENIED
				params.Reason = "user not in Allow List"
			}

		// Set delegator so that the event generated by setting the access
		// request state has an event field 'delegator: <plugin_name>:<delegator>'
		delegator := "delegator"
		ctx = utils.WithDelegator(ctx, fmt.Sprintf("%s:%s", cfg.PluginName, delegator))
		if err := client.SetAccessRequestState(ctx, params); err != nil {
	    	return trace.Wrap(err)
		}
		log.Printf("Request state set: %v.", params.State)
		case types.OpDelete:
			// request has been removed (expired).
			// Due to some limitations in Teleport's event system, filters
			// don't really work with OpDelete events. As such, we may get
			// OpDelete events for requests that would not typically match
			// the filter argument we supplied above.
			log.Printf("Request %s has automatically expired.", event.Resource.GetName())
		}
	case <-watcher.Done():
		return watcher.Error()
	}
}

```